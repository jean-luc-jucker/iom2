# Replace 7 extreme outliers with first median
rss_slim[outlier_ind, "MBTimeToReceiveAssistance"] <- q_median
# Re-summarise
summary(rss_slim$MBTimeToReceiveAssistance) # median still 7, min still 0, max now 195, NA still 690,
# all as expected
# Let us replace the NA with the median
rss_slim <- rss_slim %>% mutate(MBTimeToReceiveAssistance = replace_na(MBTimeToReceiveAssistance, q_median))
# Re-check NA
sum(is.na(rss_slim$MBTimeToReceiveAssistance)) # 0 as expected
# Re-summarise
summary(rss_slim$MBTimeToReceiveAssistance) # median still 7, min still 0,
# max still 195
# Let's plot our final distribution
boxplot(rss_slim$MBTimeToReceiveAssistance,
ylab = "Days",
main = "MBTimeToReceiveAssistance"
)
# Not looking much better, but it's hard to improve.
# MBAssistanceDuration (days)
# Computed from Mimosa and Kobo
# interview_date [Kobo] - MicrobusinessEndDate [Mimosa]
# Summarise
summary(rss_slim$MBAssistanceDuration) # median = 169, min -146 (!), max 1951, NA 201
# NA
sum(is.na(rss_slim$MBAssistanceDuration)) # 201
# These 201 NA corresponds to the count of people who received Microbusiness assistance,
# from above:
#Microbusiness
# Yes            1184
# NA              189
# No               12
# 189 + 12 = 201
# We cannot be sure that the NA received no assistance, that said, similarly to what we done
# for TrainingDuration, we'll recode them as 0 after spotting outliers.
# We also need to investigate the negative numbers
rss_slim[rss_slim$MBAssistanceDuration <= 0 & !is.na(rss_slim$MBAssistanceDuration), "MBAssistanceDuration"]
length(rss_slim[rss_slim$MBAssistanceDuration <= 0 & !is.na(rss_slim$MBAssistanceDuration), "MBAssistanceDuration"]) # 52
# Also print levels, since there seems to be zeros
#rss_slim %>% group_by(MBAssistanceDuration) %>% summarise(count = n()) %>% print(n=351) # there
# are 2 zeros, which we will ignore; run only if needed
# There are 52 of them. That said, these should not be converted to NA, since we know the
# NA are already all accounted above. We'll replace them with the median after computing the
# median without taking account of them
# The first thing we need to do is compute the median without taking into account the zeros
length(rss_slim[rss_slim$MBAssistanceDuration > 0, "MBAssistanceDuration"]) # 1333, which is
# 1385 - 52 indeed
# Store median
q_median <- median(rss_slim[rss_slim$MBAssistanceDuration > 0, "MBAssistanceDuration"], na.rm = TRUE)
q_median
# 174.5, which is slightly higher than above (since we do not take into account zeros), indeed
# Replace 52 negative numbers with the median
rss_slim[rss_slim$MBAssistanceDuration <= 0 & !is.na(rss_slim$MBAssistanceDuration), "MBAssistanceDuration"] <- q_median
# Check no negative values remain
length(rss_slim[rss_slim$MBAssistanceDuration <= 0 & !is.na(rss_slim$MBAssistanceDuration), "MBAssistanceDuration"]) # 0 indeed
# Check NA is still 201
sum(is.na(rss_slim$MBAssistanceDuration)) # 201 indeed
# Resummarize
summary(rss_slim$MBAssistanceDuration) # median now 174.5, min now 1, max still 1951, all as expected
# Spot outliers using percentile method, with conservative threshold of 0.01/0.99
lower_bound <- quantile(rss_slim$MBAssistanceDuration, 0.01, na.rm = TRUE)
upper_bound <- quantile(rss_slim$MBAssistanceDuration, 0.99, na.rm = TRUE)
outlier_ind <- which(rss_slim$MBAssistanceDuration < lower_bound | rss_slim$MBAssistanceDuration > upper_bound)
length(rss_slim[outlier_ind, "MBAssistanceDuration"]) # 21 outliers,
sort(rss_slim[outlier_ind, "MBAssistanceDuration"]) # with smallest being 1 days or 381 days
# We don't want to get rid of lower bound outliers, but only upper bound outliers.
# So we do:
outlier_ind <- which(rss_slim$MBAssistanceDuration > upper_bound) # only take upper bound
length(rss_slim[outlier_ind, "MBAssistanceDuration"]) # 10 outliers (as expected),
sort(rss_slim[outlier_ind, "MBAssistanceDuration"]) # with smallest still 381 days
# Replace 10 extreme outliers with first median
rss_slim[outlier_ind, "MBAssistanceDuration"] <- q_median
# Re-summarise
summary(rss_slim$MBAssistanceDuration) # median still 174.5, min still 1, max now 377, NA still 201,
# all as expected
# Let us now finally code all the NA as 0 days:
rss_slim <- rss_slim %>% mutate(MBAssistanceDuration = replace_na(MBAssistanceDuration, 0))
# Re-check NA
sum(is.na(rss_slim$MBAssistanceDuration)) # 0 as expected
# Re-summarise
summary(rss_slim$MBAssistanceDuration) # median is now 158, min is now 0,
# and max is still 377, all as expected
# Let's plot our final distribution
boxplot(rss_slim$MBAssistanceDuration,
ylab = "Days",
main = "MBAssistanceDuration"
)
# Looking very good.
# Data types check
str(rss_slim) # all good
# Final NA check
colSums(is.na(rss_slim)) # all good
# Export slim recoded data
write_excel_csv(rss_slim, 'data_clean/rss_slim_recoded.csv')
# RDS version
saveRDS(rss_slim, file = 'data_clean/rss_slim_recoded.rds')
# Final size
dim(rss_slim)
# Export slim recoded data
write_excel_csv(rss_slim, 'data_clean/rss_slim_recoded.csv')
# Export slim recoded data
write_excel_csv(rss_slim, 'data_clean/rss_slim_recoded.csv')
# RDS version
saveRDS(rss_slim, file = 'data_clean/rss_slim_recoded.rds')
getwd()
library(tidyverse)
library(ggplot2)
library(GGally)
# Load res object as df, and convert strings to factors
df <- readRDS('data_clean/rss_slim.rds')%>%
mutate(across(where(is.character), as.factor))
dim(df) # 1,385 x 34
# Subset to RSS vars
df <- df %>% select(
EconomicScore, SocialScore, PsychoSocialScore, CompositeScore
)
cor(df)
theme_set(theme_light())
ggpairs(df)
# Load res object as df, and convert strings to factors
df <- readRDS('data_clean/rss_slim_recoded.rds')%>%
mutate(across(where(is.character), as.factor))
dim(df) # 1,385 x 35
# Subset to RSS vars
df <- df %>% select(
EconomicScore, SocialScore, PsychoSocialScore, CompositeScore
)
cor(df)
theme_set(theme_light())
ggpairs(df)
getwd()
library(tidyverse)
library(ggplot2)
library(GGally)
# Load res object as df, and convert strings to factors
df <- readRDS('data_clean/rss_slim_recoded.rds')%>%
mutate(across(where(is.character), as.factor))
dim(df) # 1,385 x 21
# Set iteration counter to 0. This is needed only for numbering the output .png
# plots. This needs to be an external variable.
counter <- 0
# Function
make_plots_overall <- function(df){ # fun start
for (col in colnames(df)){ # for-loop start
# (1) Some variables we'll need
# Count of non-na rows; needed for plot title
N <- sum(!is.na(df[col]))
# Count of missing observations; needed for plot title
Missing <- sum(is.na(df[col]))
# Number of levels for each factor; needed for saving plots in correct aspect
# ratio
n_levels <- dim(unique(df[col]))[1]
# Update counter; needed for plot numbering
counter <- counter + 1
# Skip items with 0 observations
# This is crucial to avoid error when wrapping long level names (these cannot
# be wrapped in there are none)
if (N == 0) next
# (2) UNORDERED FACTORS
if (is.factor(df[[col]]) & !is.ordered(df[[col]])) { # if-else start
# We remove NA here; also note we use sym(), needed mainly to reorder the
# bars in a loop; also note, fct_rev() is necessary to revert fct_infreq()
p <- ggplot(data = df[col] %>% filter(!is.na(df[col])),
aes(x=fct_rev(fct_infreq(!!sym(col)))))
# Compute percents for bars
p <- p + geom_bar(aes(y = (..count..)/sum(..count..)), width = 0.5,
fill = 'black')
if (N<100){
# Low N warning
p <- p + labs(title = paste(col, '| Overall'),
subtitle = paste0('Single-select | ', 'N = ', format(N, big.mark = ',')
, ', interpret with caution!'
))
} else {
# No warning
p <- p + labs(title = paste(col, '| Overall'),
subtitle = paste0('Single-select | ', 'N = ', format(N, big.mark = ',')
))
}
# Aesthetics
# Wrap long level names
p <- p + scale_x_discrete(labels = function(x) str_wrap(x, width = 30))
# Add percents as annotations; note, rounding percents using round() be-
# haves oddly, and it is much better to use accuracy = 0.1L
p <- p + geom_text(aes(label = scales::percent((..count..)/sum(..count..),
accuracy = 0.1L),
y = ((..count..)/sum(..count..))), stat="count",
hjust = -0.1, size=4)
# Aesthetics
p <- p + theme_minimal()
p <- p + theme(axis.title.y = element_blank(),
axis.title.x = element_blank(),
axis.text.x = element_blank(),
axis.text.y = element_text(colour='black', size = 12),
plot.margin = margin(r=25, l=1, b=0, t=1),
plot.title = element_text(size = 16),
plot.subtitle = element_text(size = 12),
panel.grid = element_blank())
# Flip coordinates; note, this is needed only to accommodate the percent an-
# notation, in combination with plot.margin(); without annotations, we might
# have simply reversed x and y everywhere to get exact same result
p <- p + coord_flip(clip = 'off')
# # Print
print(p)
# Save as png; note n_levels*1.3+1 nicely accommodates most variables for a
# MS Word output; note we decided to number files just to preserve df order
# instead of alphabetical order
if (n_levels<15) {
ggsave(paste(counter, '_', col, '.png'), path = 'plots/single_select/rss',
width = 16.5,
height = n_levels * 1.3 + 1, units = 'cm')
# If factor has more than 13 levels, it is better to use this proportion
} else {
ggsave(paste(counter, '_', col, '.png'), path = 'plots/single_select/rss',
width = 16.5,
height = n_levels * 0.9, units = 'cm')
}
# (3) ORDERED FACTORS
} else if (is.factor(df[[col]]) & is.ordered(df[[col]])){
# We remove NA here; also note we use sym(), needed mainly to reorder the
# bars in a loop; also note, fct_rev() is necessary to revert fct_infreq()
p <- ggplot(data = df[col] %>% filter(!is.na(df[col])),
aes(x=!!sym(col)))
# Compute percents for bars
p <- p + geom_bar(aes(y = (..count..)/sum(..count..)), width = 0.5,
fill = 'black')
if (N<100){
# Low N warning
p <- p + labs(title = paste(col, '| Overall'),
subtitle = paste0('Single-select | ', 'N = ', format(N, big.mark = ','),
', interpret with caution!'
))
} else {
# No warning
p <- p + labs(title = paste(col, '| Overall'),
subtitle = paste0('Single-select | ', 'N = ', format(N, big.mark = ',')
))
}
# Aesthetics
# Wrap long level names
p <- p + scale_x_discrete(labels = function(x) str_wrap(x, width = 30))
# Add percents as annotations; note, rounding percents using round() be-
# haves oddly, and it is much better to use accuracy = 0.1L
p <- p + geom_text(aes(label = scales::percent((..count..)/sum(..count..),
accuracy = 0.1L),
y = ((..count..)/sum(..count..))), stat="count",
hjust = -0.1, size=4)
# Aesthetics
p <- p + theme_minimal()
p <- p + theme(axis.title.y = element_blank(),
axis.title.x = element_blank(),
axis.text.x = element_blank(),
axis.text.y = element_text(colour='black', size = 12),
plot.margin = margin(r=25, l=1, b=0, t=1),
plot.title = element_text(size = 16),
plot.subtitle = element_text(size = 12),
panel.grid = element_blank())
# Flip coordinates; note, this is needed only to accommodate the percent an-
# notation, in combination with plot.margin(); without annotations, we might
# have simply reversed x and y everywhere to get exact same result
p <- p + coord_flip(clip = 'off')
# # Print
print(p)
# Save as png; note n_levels*1.3+1 nicely accommodates most variables for a
# MS Word output; note we decided to number files just to preserve df order
# instead of alphabetical order
if (n_levels<15) {
ggsave(paste(counter, '_', col, '.png'), path = 'plots/single_select/rss',
width = 16.5,
height = n_levels * 1.3 + 1, units = 'cm')
# If factor has more than 13 levels, it is better to use this proportion
} else {
ggsave(paste(counter, '_', col, '.png'), path = 'plots/single_select/rss',
width = 16.5,
height = n_levels * 0.9, units = 'cm')
}
# (4) NUMERIC
} else if (is.numeric(df[[col]])) {
# Plot
p <- ggplot(data = df, aes(y = !!sym(col), x=""))
p <- p + geom_jitter(width = 0.2, alpha=0.8, size=0.6)
p <- p +  geom_boxplot(alpha=0.9, fill='transparent')
#p <- p + scale_y_continuous(breaks = round(seq(min(df[[col]]), max(df[[col]]), by = 10),1))
# PUT above line once data are clean! Currently AmountSpent is infinite
p <- p + coord_flip()
if (N<100){
# Low N warning
p <- p + labs(title = paste(col, '| Overall'),
subtitle = paste0('Single-select | ', 'N = ', format(N, big.mark = ','),
', interpret with caution!'
))
} else {
# No warning
p <- p + labs(title = paste(col, '| Overall'),
subtitle = paste0('Single-select | ', 'N = ', format(N, big.mark = ',')
))
}
# Aesthetics
p <- p + theme_minimal()
p <- p + theme(axis.title.y = element_blank(),
axis.text.y = element_text(colour='black', size = 12),
axis.text.x = element_text(colour='black', size = 12),
axis.title.x = element_text(colour='black', size = 12),
legend.position = 'none',
#plot.margin = margin(r=25, l=1, b=0, t=1),
plot.title = element_text(size = 16),
plot.subtitle = element_text(size = 12),
panel.grid = element_blank())
# Print
print(p)
# Export
ggsave(paste(counter, '_', col, '.png'), path = 'plots/single_select/rss',
width = 16.5,
height = 5, units = 'cm') # initially *1.3
# (5) OTHER
} else { # reput to above line
print(paste('Column', col, 'is a character; not plotted'))
} # if-else end
} # for-loop end
} # fun end
# Implement on full data
make_plots_overall(df)
# Discard unplottable variables
df <- df %>% select(-c(MimosaID, InterviewDate))
# Discard unplottable variables
df <- df %>% select(-c(ID, InterviewDate))
# Discard unplottable variables
df <- df %>% select(-c(ID))
# Set iteration counter to 0. This is needed only for numbering the output .png
# plots. This needs to be an external variable.
counter <- 0
# Function
make_plots_overall <- function(df){ # fun start
for (col in colnames(df)){ # for-loop start
# (1) Some variables we'll need
# Count of non-na rows; needed for plot title
N <- sum(!is.na(df[col]))
# Count of missing observations; needed for plot title
Missing <- sum(is.na(df[col]))
# Number of levels for each factor; needed for saving plots in correct aspect
# ratio
n_levels <- dim(unique(df[col]))[1]
# Update counter; needed for plot numbering
counter <- counter + 1
# Skip items with 0 observations
# This is crucial to avoid error when wrapping long level names (these cannot
# be wrapped in there are none)
if (N == 0) next
# (2) UNORDERED FACTORS
if (is.factor(df[[col]]) & !is.ordered(df[[col]])) { # if-else start
# We remove NA here; also note we use sym(), needed mainly to reorder the
# bars in a loop; also note, fct_rev() is necessary to revert fct_infreq()
p <- ggplot(data = df[col] %>% filter(!is.na(df[col])),
aes(x=fct_rev(fct_infreq(!!sym(col)))))
# Compute percents for bars
p <- p + geom_bar(aes(y = (..count..)/sum(..count..)), width = 0.5,
fill = 'black')
if (N<100){
# Low N warning
p <- p + labs(title = paste(col, '| Overall'),
subtitle = paste0('Single-select | ', 'N = ', format(N, big.mark = ',')
, ', interpret with caution!'
))
} else {
# No warning
p <- p + labs(title = paste(col, '| Overall'),
subtitle = paste0('Single-select | ', 'N = ', format(N, big.mark = ',')
))
}
# Aesthetics
# Wrap long level names
p <- p + scale_x_discrete(labels = function(x) str_wrap(x, width = 30))
# Add percents as annotations; note, rounding percents using round() be-
# haves oddly, and it is much better to use accuracy = 0.1L
p <- p + geom_text(aes(label = scales::percent((..count..)/sum(..count..),
accuracy = 0.1L),
y = ((..count..)/sum(..count..))), stat="count",
hjust = -0.1, size=4)
# Aesthetics
p <- p + theme_minimal()
p <- p + theme(axis.title.y = element_blank(),
axis.title.x = element_blank(),
axis.text.x = element_blank(),
axis.text.y = element_text(colour='black', size = 12),
plot.margin = margin(r=25, l=1, b=0, t=1),
plot.title = element_text(size = 16),
plot.subtitle = element_text(size = 12),
panel.grid = element_blank())
# Flip coordinates; note, this is needed only to accommodate the percent an-
# notation, in combination with plot.margin(); without annotations, we might
# have simply reversed x and y everywhere to get exact same result
p <- p + coord_flip(clip = 'off')
# # Print
print(p)
# Save as png; note n_levels*1.3+1 nicely accommodates most variables for a
# MS Word output; note we decided to number files just to preserve df order
# instead of alphabetical order
if (n_levels<15) {
ggsave(paste(counter, '_', col, '.png'), path = 'plots/single_select/rss',
width = 16.5,
height = n_levels * 1.3 + 1, units = 'cm')
# If factor has more than 13 levels, it is better to use this proportion
} else {
ggsave(paste(counter, '_', col, '.png'), path = 'plots/single_select/rss',
width = 16.5,
height = n_levels * 0.9, units = 'cm')
}
# (3) ORDERED FACTORS
} else if (is.factor(df[[col]]) & is.ordered(df[[col]])){
# We remove NA here; also note we use sym(), needed mainly to reorder the
# bars in a loop; also note, fct_rev() is necessary to revert fct_infreq()
p <- ggplot(data = df[col] %>% filter(!is.na(df[col])),
aes(x=!!sym(col)))
# Compute percents for bars
p <- p + geom_bar(aes(y = (..count..)/sum(..count..)), width = 0.5,
fill = 'black')
if (N<100){
# Low N warning
p <- p + labs(title = paste(col, '| Overall'),
subtitle = paste0('Single-select | ', 'N = ', format(N, big.mark = ','),
', interpret with caution!'
))
} else {
# No warning
p <- p + labs(title = paste(col, '| Overall'),
subtitle = paste0('Single-select | ', 'N = ', format(N, big.mark = ',')
))
}
# Aesthetics
# Wrap long level names
p <- p + scale_x_discrete(labels = function(x) str_wrap(x, width = 30))
# Add percents as annotations; note, rounding percents using round() be-
# haves oddly, and it is much better to use accuracy = 0.1L
p <- p + geom_text(aes(label = scales::percent((..count..)/sum(..count..),
accuracy = 0.1L),
y = ((..count..)/sum(..count..))), stat="count",
hjust = -0.1, size=4)
# Aesthetics
p <- p + theme_minimal()
p <- p + theme(axis.title.y = element_blank(),
axis.title.x = element_blank(),
axis.text.x = element_blank(),
axis.text.y = element_text(colour='black', size = 12),
plot.margin = margin(r=25, l=1, b=0, t=1),
plot.title = element_text(size = 16),
plot.subtitle = element_text(size = 12),
panel.grid = element_blank())
# Flip coordinates; note, this is needed only to accommodate the percent an-
# notation, in combination with plot.margin(); without annotations, we might
# have simply reversed x and y everywhere to get exact same result
p <- p + coord_flip(clip = 'off')
# # Print
print(p)
# Save as png; note n_levels*1.3+1 nicely accommodates most variables for a
# MS Word output; note we decided to number files just to preserve df order
# instead of alphabetical order
if (n_levels<15) {
ggsave(paste(counter, '_', col, '.png'), path = 'plots/single_select/rss',
width = 16.5,
height = n_levels * 1.3 + 1, units = 'cm')
# If factor has more than 13 levels, it is better to use this proportion
} else {
ggsave(paste(counter, '_', col, '.png'), path = 'plots/single_select/rss',
width = 16.5,
height = n_levels * 0.9, units = 'cm')
}
# (4) NUMERIC
} else if (is.numeric(df[[col]])) {
# Plot
p <- ggplot(data = df, aes(y = !!sym(col), x=""))
p <- p + geom_jitter(width = 0.2, alpha=0.8, size=0.6)
p <- p +  geom_boxplot(alpha=0.9, fill='transparent')
#p <- p + scale_y_continuous(breaks = round(seq(min(df[[col]]), max(df[[col]]), by = 10),1))
# PUT above line once data are clean! Currently AmountSpent is infinite
p <- p + coord_flip()
if (N<100){
# Low N warning
p <- p + labs(title = paste(col, '| Overall'),
subtitle = paste0('Single-select | ', 'N = ', format(N, big.mark = ','),
', interpret with caution!'
))
} else {
# No warning
p <- p + labs(title = paste(col, '| Overall'),
subtitle = paste0('Single-select | ', 'N = ', format(N, big.mark = ',')
))
}
# Aesthetics
p <- p + theme_minimal()
p <- p + theme(axis.title.y = element_blank(),
axis.text.y = element_text(colour='black', size = 12),
axis.text.x = element_text(colour='black', size = 12),
axis.title.x = element_text(colour='black', size = 12),
legend.position = 'none',
#plot.margin = margin(r=25, l=1, b=0, t=1),
plot.title = element_text(size = 16),
plot.subtitle = element_text(size = 12),
panel.grid = element_blank())
# Print
print(p)
# Export
ggsave(paste(counter, '_', col, '.png'), path = 'plots/single_select/rss',
width = 16.5,
height = 5, units = 'cm') # initially *1.3
# (5) OTHER
} else { # reput to above line
print(paste('Column', col, 'is a character; not plotted'))
} # if-else end
} # for-loop end
} # fun end
# Implement on full data
make_plots_overall(df)
summary(df$age)
